
def can_transfer_data(n, q, s, sensor_to_queue, queue_capacities, downlink_windows):
    queues = [0] * q

    # Process each downlink window
    for window in downlink_windows:
        # Transfer capacity during window
        transfer_capacity = window[0]
        
        # Data generated by each sensor before downlink window
        data_generated = window[1:]

        # Add data to their respective queues
        for i in range(s):
            queue_index = sensor_to_queue[i] - 1  # Adjust index (1 to Q -> 0 to Q-1)
            queues[queue_index] += data_generated[i]
            
            # Check if any queue exceeds its capacity
            if queues[queue_index] > queue_capacities[queue_index]:
                return "impossible"
        
        # Sort queues from the most filled to least filled
        queues.sort(reverse=True)

        # Transfer data to Earth while respecting the transfer capacity
        for i in range(q):
            if transfer_capacity == 0:
                break
            transfer_amount = min(queues[i], transfer_capacity)
            queues[i] -= transfer_amount
            transfer_capacity -= transfer_amount
    
    # Check if all queues are empty at the end
    if all(queue == 0 for queue in queues):
        return "possible"
    else:
        return "impossible"

# Inputs
n, q, s = map(int, input().split())
sensor_to_queue = list(map(int, input().split()))
queue_capacities = list(map(int, input().split()))

# Read downlink windows
downlink_windows = []
for _ in range(n):
    downlink_windows.append(list(map(int, input().split())))

# Can transfer Function
result = can_transfer_data(n, q, s, sensor_to_queue, queue_capacities, downlink_windows)
print(result)
